From 12fe2bd8fb80b71bcbc6526f916e6225c12610ee Mon Sep 17 00:00:00 2001
From: Li Dongyang <dongyang.li@anu.edu.au>
Date: Tue, 29 Mar 2016 14:57:57 +1100
Subject: [PATCH 08/19] LU-6215 o2iblnd: ib_alloc_fast_reg_mr() removed in 4.3

ib_alloc_fast_reg_mr() is replaced by a more generic
ib_alloc_mr() since kernel 4.3

Linux-commit: d9f272c523db47a56a64942eb6f25361c400de66

Signed-off-by: Li Dongyang <dongyang.li@anu.edu.au>
Change-Id: I53f4e7c395c83d731aaa342f308f878b07b54d61
Reviewed-on: http://review.whamcloud.com/19185
Reviewed-by: Dmitry Eremin <dmitry.eremin@intel.com>
Tested-by: Jenkins
Tested-by: Maloo <hpdd-maloo@intel.com>
Reviewed-by: James Simmons <uja.ornl@yahoo.com>
Reviewed-by: Oleg Drokin <oleg.drokin@intel.com>
---
 lnet/autoconf/lustre-lnet.m4 | 51 ++----------------------
 lnet/klnds/o2iblnd/o2iblnd.c | 92 +++++++++++++++++++++++++++++++++++++++++++-
 2 files changed, 95 insertions(+), 48 deletions(-)

diff --git a/lnet/autoconf/lustre-lnet.m4 b/lnet/autoconf/lustre-lnet.m4
index 2e2adb2..a1498aa 100644
--- a/lnet/autoconf/lustre-lnet.m4
+++ b/lnet/autoconf/lustre-lnet.m4
@@ -395,8 +395,10 @@ AS_IF([test $ENABLEO2IB != "no"], [
 		AC_DEFINE(HAVE_IB_CQ_INIT_ATTR, 1,
 			[struct ib_cq_init_attr is used by ib_create_cq])
 	])
+])
 
-	# 4.3 removed ib_alloc_fast_reg_mr()
+# 4.3 removed ib_alloc_fast_reg_mr()
+AS_IF([test $ENABLEO2IB != "no"], [
 	LB_CHECK_COMPILE([if 'ib_alloc_fast_reg_mr' exists],
 	ib_alloc_fast_reg_mr, [
 		#ifdef HAVE_COMPAT_RDMA
@@ -415,52 +417,7 @@ AS_IF([test $ENABLEO2IB != "no"], [
 		AC_DEFINE(HAVE_IB_ALLOC_FAST_REG_MR, 1,
 			[ib_alloc_fast_reg_mr is defined])
 	])
-
-	# In v4.4 Linux kernel,
-	# commit e622f2f4ad2142d2a613a57fb85f8cf737935ef5
-	# split up struct ib_send_wr so that all non-trivial verbs
-	# use their own structure which embedds struct ib_send_wr.
-	LB_CHECK_COMPILE([if 'struct ib_rdma_wr' is defined],
-	ib_rdma_wr, [
-		#ifdef HAVE_COMPAT_RDMA
-		#undef PACKAGE_NAME
-		#undef PACKAGE_TARNAME
-		#undef PACKAGE_VERSION
-		#undef PACKAGE_STRING
-		#undef PACKAGE_BUGREPORT
-		#undef PACKAGE_URL
-		#include <linux/compat-2.6.h>
-		#endif
-		#include <rdma/ib_verbs.h>
-	],[
-		struct ib_rdma_wr *wr __attribute__ ((unused));
-
-		wr = rdma_wr(NULL);
-	],[
-		AC_DEFINE(HAVE_IB_RDMA_WR, 1,
-			[struct ib_rdma_wr is defined])
-	])
-
-	# new fast registration API introduced in 4.4
-	LB_CHECK_COMPILE([if 'ib_map_mr_sg' exists],
-	ib_map_mr_sg, [
-		#ifdef HAVE_COMPAT_RDMA
-		#undef PACKAGE_NAME
-		#undef PACKAGE_TARNAME
-		#undef PACKAGE_VERSION
-		#undef PACKAGE_STRING
-		#undef PACKAGE_BUGREPORT
-		#undef PACKAGE_URL
-		#include <linux/compat-2.6.h>
-		#endif
-		#include <rdma/ib_verbs.h>
-	],[
-		ib_map_mr_sg(NULL, NULL, 0, 0);
-	],[
-		AC_DEFINE(HAVE_IB_MAP_MR_SG, 1,
-			[ib_map_mr_sg exists])
-	])
-]) # ENABLEO2IB != "no"
+])
 ]) # LN_CONFIG_O2IB
 
 #
diff --git a/lnet/klnds/o2iblnd/o2iblnd.c b/lnet/klnds/o2iblnd/o2iblnd.c
index 00c4ce2..57f51ca 100644
--- a/lnet/klnds/o2iblnd/o2iblnd.c
+++ b/lnet/klnds/o2iblnd/o2iblnd.c
@@ -1444,7 +1444,97 @@ kiblnd_create_fmr_pool(kib_fmr_poolset_t *fps, kib_fmr_pool_t **pp_fpo)
 		.dirty_watermark   = fps->fps_flush_trigger,
 		.flush_function    = NULL,
 		.flush_arg         = NULL,
-		.cache             = !!*kiblnd_tunables.kib_fmr_cache};
+		.cache             = !!fps->fps_cache };
+	int rc = 0;
+
+	fpo->fmr.fpo_fmr_pool = ib_create_fmr_pool(fpo->fpo_hdev->ibh_pd,
+						   &param);
+	if (IS_ERR(fpo->fmr.fpo_fmr_pool)) {
+		rc = PTR_ERR(fpo->fmr.fpo_fmr_pool);
+		if (rc != -ENOSYS)
+			CERROR("Failed to create FMR pool: %d\n", rc);
+		else
+			CERROR("FMRs are not supported\n");
+	}
+
+	return rc;
+}
+
+static int kiblnd_alloc_freg_pool(kib_fmr_poolset_t *fps, kib_fmr_pool_t *fpo)
+{
+	struct kib_fast_reg_descriptor *frd, *tmp;
+	int i, rc;
+
+	INIT_LIST_HEAD(&fpo->fast_reg.fpo_pool_list);
+	fpo->fast_reg.fpo_pool_size = 0;
+	for (i = 0; i < fps->fps_pool_size; i++) {
+		LIBCFS_CPT_ALLOC(frd, lnet_cpt_table(), fps->fps_cpt,
+				 sizeof(*frd));
+		if (!frd) {
+			CERROR("Failed to allocate a new fast_reg descriptor\n");
+			rc = -ENOMEM;
+			goto out;
+		}
+		frd->frd_mr = NULL;
+
+		frd->frd_frpl = ib_alloc_fast_reg_page_list(fpo->fpo_hdev->ibh_ibdev,
+							    LNET_MAX_PAYLOAD/PAGE_SIZE);
+		if (IS_ERR(frd->frd_frpl)) {
+			rc = PTR_ERR(frd->frd_frpl);
+			CERROR("Failed to allocate ib_fast_reg_page_list: %d\n",
+				rc);
+			frd->frd_frpl = NULL;
+			goto out_middle;
+		}
+
+#ifdef HAVE_IB_ALLOC_FAST_REG_MR
+		frd->frd_mr = ib_alloc_fast_reg_mr(fpo->fpo_hdev->ibh_pd,
+						   LNET_MAX_PAYLOAD/PAGE_SIZE);
+#else
+		frd->frd_mr = ib_alloc_mr(fpo->fpo_hdev->ibh_pd,
+					  IB_MR_TYPE_MEM_REG,
+					  LNET_MAX_PAYLOAD/PAGE_SIZE);
+#endif
+		if (IS_ERR(frd->frd_mr)) {
+			rc = PTR_ERR(frd->frd_mr);
+			CERROR("Failed to allocate ib_fast_reg_mr: %d\n", rc);
+			frd->frd_mr = NULL;
+			goto out_middle;
+		}
+
+		frd->frd_valid = true;
+
+		list_add_tail(&frd->frd_list, &fpo->fast_reg.fpo_pool_list);
+		fpo->fast_reg.fpo_pool_size++;
+	}
+
+	return 0;
+
+out_middle:
+	if (frd->frd_mr)
+		ib_dereg_mr(frd->frd_mr);
+	if (frd->frd_frpl)
+		ib_free_fast_reg_page_list(frd->frd_frpl);
+	LIBCFS_FREE(frd, sizeof(*frd));
+
+out:
+	list_for_each_entry_safe(frd, tmp, &fpo->fast_reg.fpo_pool_list,
+				 frd_list) {
+		list_del(&frd->frd_list);
+		ib_free_fast_reg_page_list(frd->frd_frpl);
+		ib_dereg_mr(frd->frd_mr);
+		LIBCFS_FREE(frd, sizeof(*frd));
+	}
+
+	return rc;
+}
+
+static int
+kiblnd_create_fmr_pool(kib_fmr_poolset_t *fps, kib_fmr_pool_t **pp_fpo)
+{
+	struct ib_device_attr *dev_attr;
+	kib_dev_t *dev = fps->fps_net->ibn_dev;
+	kib_fmr_pool_t *fpo;
 	int rc;
 
 	LIBCFS_CPT_ALLOC(fpo, lnet_cpt_table(), fps->fps_cpt, sizeof(*fpo));
-- 
2.8.2

