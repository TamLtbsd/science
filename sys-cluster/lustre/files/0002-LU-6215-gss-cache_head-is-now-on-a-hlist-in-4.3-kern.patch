From 449e99feba4cfd3e417cdfc87e0eb33e163c2cb6 Mon Sep 17 00:00:00 2001
From: Li Dongyang <dongyang.li@anu.edu.au>
Date: Tue, 1 Mar 2016 16:10:48 +1100
Subject: [PATCH 02/19] LU-6215 gss: cache_head is now on a hlist in 4.3+
 kernels

Since kernel 4.3 struct cache_head switched from a single
list to a hlist. This patch handles the change.

Linux-commit: 129e5824cd96d9289679973f0ff7c48e88d569bb

Signed-off-by: Li Dongyang <dongyang.li@anu.edu.au>
Change-Id: Iec4c7d0acf106a8f7b60d72eb2038b6d9e12f422
Reviewed-on: http://review.whamcloud.com/18728
Tested-by: Jenkins
Tested-by: Maloo <hpdd-maloo@intel.com>
Reviewed-by: James Simmons <uja.ornl@yahoo.com>
Reviewed-by: Dmitry Eremin <dmitry.eremin@intel.com>
Reviewed-by: Oleg Drokin <oleg.drokin@intel.com>
---
 lustre/autoconf/lustre-core.m4     | 46 +++++++++++++++++++++++++++++++++++++
 lustre/ptlrpc/gss/gss_svc_upcall.c | 47 ++++++++++++++++++++++++++++++++------
 2 files changed, 86 insertions(+), 7 deletions(-)

diff --git a/lustre/autoconf/lustre-core.m4 b/lustre/autoconf/lustre-core.m4
index b8285d0..8ed3500 100644
--- a/lustre/autoconf/lustre-core.m4
+++ b/lustre/autoconf/lustre-core.m4
@@ -1948,6 +1948,49 @@ bio_endio, [
 ]) # LC_BIO_ENDIO_USES_ONE_ARG
 
 #
+# LC_HAVE_LOOP_CTL_GET_FREE
+#
+# 4.x kernel have moved userspace APIs to
+# the separate directory and all of them
+# support LOOP_CTL_GET_FREE
+#
+AC_DEFUN([LC_HAVE_LOOP_CTL_GET_FREE], [
+LB_CHECK_FILE([$LINUX/include/linux/loop.h], [
+	LB_CHECK_COMPILE([if have 'HAVE_LOOP_CTL_GET_FREE'],
+	LOOP_CTL_GET_FREE, [
+		#include <linux/loop.h>
+	],[
+		int i;
+
+		i = LOOP_CTL_GET_FREE;
+	],[
+		AC_DEFINE(HAVE_LOOP_CTL_GET_FREE, 1,
+			[LOOP_CTL_GET_FREE exist])
+	])
+],[
+	AC_DEFINE(HAVE_LOOP_CTL_GET_FREE, 1,
+		[kernel has LOOP_CTL_GET_FREE])
+])
+]) # LC_HAVE_LOOP_CTL_GET_FREE
+
+#
+# LC_HAVE_CACHE_HEAD_HLIST
+#
+# 4.3 kernel swiched to hlist for cache_head
+#
+AC_DEFUN([LC_HAVE_CACHE_HEAD_HLIST], [
+LB_CHECK_COMPILE([if 'struct cache_head' has 'cache_list' field],
+cache_head_has_hlist, [
+	#include <linux/sunrpc/cache.h>
+],[
+	do {} while(sizeof(((struct cache_head *)0)->cache_list));
+],[
+	AC_DEFINE(HAVE_CACHE_HEAD_HLIST, 1,
+		[cache_head has hlist cache_list])
+])
+]) # LC_HAVE_CACHE_HEAD_HLIST
+
+#
 # LC_PROG_LINUX
 #
 # Lustre linux kernel checks
@@ -2108,6 +2151,9 @@ AC_DEFUN([LC_PROG_LINUX], [
 	LC_BIO_ENDIO_USES_ONE_ARG
 	LC_SYMLINK_OPS_USE_NAMEIDATA
 
+	# 4.3
+	LC_HAVE_CACHE_HEAD_HLIST
+
 	#
 	AS_IF([test "x$enable_server" != xno], [
 		LC_FUNC_DEV_SET_RDONLY
diff --git a/lustre/ptlrpc/gss/gss_svc_upcall.c b/lustre/ptlrpc/gss/gss_svc_upcall.c
index 429b1eb..2786d69 100644
--- a/lustre/ptlrpc/gss/gss_svc_upcall.c
+++ b/lustre/ptlrpc/gss/gss_svc_upcall.c
@@ -149,7 +149,11 @@ struct rsi {
 	int                     major_status, minor_status;
 };
 
+#ifdef HAVE_CACHE_HEAD_HLIST
+static struct hlist_head rsi_table[RSI_HASHMAX];
+#else
 static struct cache_head *rsi_table[RSI_HASHMAX];
+#endif
 static struct cache_detail rsi_cache;
 static struct rsi *rsi_update(struct rsi *new, struct rsi *old);
 static struct rsi *rsi_lookup(struct rsi *item);
@@ -242,7 +246,11 @@ static void rsi_put(struct kref *ref)
 {
         struct rsi *rsi = container_of(ref, struct rsi, h.ref);
 
-        LASSERT(rsi->h.next == NULL);
+#ifdef HAVE_CACHE_HEAD_HLIST
+	LASSERT(rsi->h.cache_list.next == NULL);
+#else
+	LASSERT(rsi->h.next == NULL);
+#endif
         rsi_free(rsi);
         OBD_FREE_PTR(rsi);
 }
@@ -430,7 +438,11 @@ struct rsc {
         struct gss_svc_ctx      ctx;
 };
 
+#ifdef HAVE_CACHE_HEAD_HLIST
+static struct hlist_head rsc_table[RSC_HASHMAX];
+#else
 static struct cache_head *rsc_table[RSC_HASHMAX];
+#endif
 static struct cache_detail rsc_cache;
 static struct rsc *rsc_update(struct rsc *new, struct rsc *old);
 static struct rsc *rsc_lookup(struct rsc *item);
@@ -477,7 +489,11 @@ static void rsc_put(struct kref *ref)
 {
         struct rsc *rsci = container_of(ref, struct rsc, h.ref);
 
+#ifdef HAVE_CACHE_HEAD_HLIST
+	LASSERT(rsci->h.cache_list.next == NULL);
+#else
         LASSERT(rsci->h.next == NULL);
+#endif
         rsc_free(rsci);
         OBD_FREE_PTR(rsci);
 }
@@ -693,24 +709,41 @@ typedef int rsc_entry_match(struct rsc *rscp, long data);
 
 static void rsc_flush(rsc_entry_match *match, long data)
 {
-        struct cache_head **ch;
+#ifdef HAVE_CACHE_HEAD_HLIST
+	struct cache_head *ch = NULL;
+	struct hlist_head *head;
+#else
+	struct cache_head **ch;
+#endif
         struct rsc *rscp;
         int n;
         ENTRY;
 
 	write_lock(&rsc_cache.hash_lock);
         for (n = 0; n < RSC_HASHMAX; n++) {
-                for (ch = &rsc_cache.hash_table[n]; *ch;) {
-                        rscp = container_of(*ch, struct rsc, h);
+#ifdef HAVE_CACHE_HEAD_HLIST
+		head = &rsc_cache.hash_table[n];
+		hlist_for_each_entry(ch, head, cache_list) {
+			rscp = container_of(ch, struct rsc, h);
+#else
+		for (ch = &rsc_cache.hash_table[n]; *ch;) {
+			rscp = container_of(*ch, struct rsc, h);
+#endif
 
                         if (!match(rscp, data)) {
-                                ch = &((*ch)->next);
+#ifndef HAVE_CACHE_HEAD_HLIST
+				ch = &((*ch)->next);
+#endif
                                 continue;
                         }
 
                         /* it seems simply set NEGATIVE doesn't work */
-                        *ch = (*ch)->next;
-                        rscp->h.next = NULL;
+#ifdef HAVE_CACHE_HEAD_HLIST
+			hlist_del_init(&ch->cache_list);
+#else
+			*ch = (*ch)->next;
+			rscp->h.next = NULL;
+#endif
                         cache_get(&rscp->h);
 			set_bit(CACHE_NEGATIVE, &rscp->h.flags);
                         COMPAT_RSC_PUT(&rscp->h, &rsc_cache);
-- 
2.8.2

