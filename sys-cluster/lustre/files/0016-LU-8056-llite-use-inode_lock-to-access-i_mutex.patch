From 917e3d42d9fe0584c740584db5c5f59cf6875c9f Mon Sep 17 00:00:00 2001
From: Li Dongyang <dongyang.li@anu.edu.au>
Date: Mon, 16 May 2016 17:40:55 +1000
Subject: [PATCH 16/19] LU-8056 llite: use inode_lock to access i_mutex

Linux kernel 4.5 introduced wrappers for i_mutex as the type
of i_mutex will be changed in the future.
This patch prepares us for the upcoming type change. It also
includes a patch from linux kernel removing unused declaration
to make the room for the wrappers mentioned above.

Note that this patch only touches the llite part. osd-ldiskfs still
calls mutex_{lock,unlock} on i_mutex.

Linux-commit:57b8f112cfe6622ddddb8c2641206bb5fa8a112d
Linux-commit:5955102c9984fa081b2d570cfac75c97eecf8f3b

Signed-off-by: Li Dongyang <dongyang.li@anu.edu.au>
Change-Id: Ia4c30443cddfaa5232e1dc1519c33c97dba2a271
---
 lustre/autoconf/lustre-core.m4 | 20 ++++++++++++++++++++
 lustre/include/lustre_compat.h |  6 ++++++
 lustre/include/lvfs.h          |  4 ++--
 lustre/llite/dir.c             |  4 ++--
 lustre/llite/file.c            | 29 +++++++++++++++++++----------
 lustre/llite/llite_internal.h  |  2 --
 lustre/llite/llite_lib.c       |  8 ++++----
 lustre/llite/llite_nfs.c       |  4 ++--
 lustre/llite/lloop.c           |  4 ++--
 lustre/llite/rw26.c            |  4 ++--
 lustre/llite/vvp_io.c          |  4 ++--
 lustre/llite/vvp_page.c        |  4 ++--
 12 files changed, 63 insertions(+), 30 deletions(-)

diff --git a/lustre/autoconf/lustre-core.m4 b/lustre/autoconf/lustre-core.m4
index 9497cdd..622345f 100644
--- a/lustre/autoconf/lustre-core.m4
+++ b/lustre/autoconf/lustre-core.m4
@@ -2045,6 +2045,23 @@ key_payload_data_array, [
 ]) #LC_HAVE_KEY_PAYLOAD_DATA_ARRAY
 
 #
+# LC_HAVE_INODE_LOCK
+#
+# 4.5 introduced inode_lock
+#
+AC_DEFUN([LC_HAVE_INODE_LOCK], [
+LB_CHECK_COMPILE([if 'inode_lock' is defined],
+inode_lock, [
+	#include <linux/fs.h>
+],[
+	inode_lock(NULL);
+], [
+	AC_DEFINE(HAVE_INODE_LOCK, 1,
+		  [inode_lock is defined])
+])
+]) # LC_HAVE_INODE_LOCK
+
+#
 # LC_PROG_LINUX
 #
 # Lustre linux kernel checks
@@ -2213,6 +2230,9 @@ AC_DEFUN([LC_PROG_LINUX], [
 	LC_HAVE_QC_MAKE_REQUEST_FN
 	LC_HAVE_KEY_PAYLOAD_DATA_ARRAY
 
+	# 4.5
+	LC_HAVE_INODE_LOCK
+
 	#
 	AS_IF([test "x$enable_server" != xno], [
 		LC_FUNC_DEV_SET_RDONLY
diff --git a/lustre/include/lustre_compat.h b/lustre/include/lustre_compat.h
index 4e9f3ac..2a5a2fd 100644
--- a/lustre/include/lustre_compat.h
+++ b/lustre/include/lustre_compat.h
@@ -370,6 +370,12 @@ static inline struct dentry *d_make_root(struct inode *root)
 #define ll_vfs_unlink(a, b) vfs_unlink(a, b)
 #endif
 
+#ifndef HAVE_INODE_LOCK
+# define inode_lock(inode) mutex_lock(&(inode)->i_mutex)
+# define inode_unlock(inode) mutex_unlock(&(inode)->i_mutex)
+# define inode_trylock(inode) mutex_trylock(&(inode)->i_mutex)
+#endif
+
 #ifndef HAVE_RADIX_EXCEPTION_ENTRY
 static inline int radix_tree_exceptional_entry(void *arg)
 {
diff --git a/lustre/include/lvfs.h b/lustre/include/lvfs.h
index be4187f..2bdee77 100644
--- a/lustre/include/lvfs.h
+++ b/lustre/include/lvfs.h
@@ -86,9 +86,9 @@ ll_lookup_one_len(const char *fid_name, struct dentry *dparent,
 {
 	struct dentry *dchild;
 
-	mutex_lock(&dparent->d_inode->i_mutex);
+	inode_lock(dparent->d_inode);
 	dchild = lookup_one_len(fid_name, dparent, fid_namelen);
-	mutex_unlock(&dparent->d_inode->i_mutex);
+	inode_unlock(dparent->d_inode);
 
 	if (IS_ERR(dchild) || dchild->d_inode == NULL)
 		return dchild;
diff --git a/lustre/llite/dir.c b/lustre/llite/dir.c
index 4f28145..f657725 100644
--- a/lustre/llite/dir.c
+++ b/lustre/llite/dir.c
@@ -1736,7 +1736,7 @@ static loff_t ll_dir_seek(struct file *file, loff_t offset, int origin)
         loff_t ret = -EINVAL;
         ENTRY;
 
-	mutex_lock(&inode->i_mutex);
+	inode_lock(inode);
         switch (origin) {
                 case SEEK_SET:
                         break;
@@ -1774,7 +1774,7 @@ static loff_t ll_dir_seek(struct file *file, loff_t offset, int origin)
         GOTO(out, ret);
 
 out:
-	mutex_unlock(&inode->i_mutex);
+	inode_unlock(inode);
         return ret;
 }
 
diff --git a/lustre/llite/file.c b/lustre/llite/file.c
index d1819c6..b8670c7 100644
--- a/lustre/llite/file.c
+++ b/lustre/llite/file.c
@@ -2144,13 +2144,13 @@ static int ll_hsm_import(struct inode *inode, struct file *file,
 			 ATTR_MTIME | ATTR_MTIME_SET |
 			 ATTR_ATIME | ATTR_ATIME_SET;
 
-	mutex_lock(&inode->i_mutex);
+	inode_lock(inode);
 
 	rc = ll_setattr_raw(file->f_path.dentry, attr, true);
 	if (rc == -ENODATA)
 		rc = 0;
 
-	mutex_unlock(&inode->i_mutex);
+	inode_unlock(inode);
 
 out:
 	if (hss != NULL)
@@ -2197,9 +2197,9 @@ static int ll_file_futimes_3(struct file *file, const struct ll_futimes_3 *lfu)
 	if (!S_ISREG(inode->i_mode))
 		RETURN(-EINVAL);
 
-	mutex_lock(&inode->i_mutex);
+	inode_lock(inode);
 	rc = ll_setattr_raw(file->f_path.dentry, &ia, false);
-	mutex_unlock(&inode->i_mutex);
+	inode_unlock(inode);
 
 	RETURN(rc);
 }
@@ -2598,9 +2598,9 @@ generic_file_llseek_size(struct file *file, loff_t offset, int origin,
 		 * SEEK_CURs. Note that parallel writes and reads behave
 		 * like SEEK_SET.
 		 */
-		mutex_lock(&inode->i_mutex);
+		inode_lock(inode);
 		offset = llseek_execute(file, file->f_pos + offset, maxsize);
-		mutex_unlock(&inode->i_mutex);
+		inode_unlock(inode);
 		return offset;
 	case SEEK_DATA:
 		/*
@@ -2758,7 +2758,7 @@ int ll_fsync(struct file *file, struct dentry *dentry, int datasync)
 
 #ifdef HAVE_FILE_FSYNC_4ARGS
 	rc = filemap_write_and_wait_range(inode->i_mapping, start, end);
-	mutex_lock(&inode->i_mutex);
+	inode_lock(inode);
 #else
 	/* fsync's caller has already called _fdata{sync,write}, we want
 	 * that IO to finish before calling the osc and mdc sync methods */
@@ -2796,7 +2796,7 @@ int ll_fsync(struct file *file, struct dentry *dentry, int datasync)
 	}
 
 #ifdef HAVE_FILE_FSYNC_4ARGS
-	mutex_unlock(&inode->i_mutex);
+	inode_unlock(inode);
 #endif
 	RETURN(rc);
 }
@@ -3021,7 +3021,15 @@ int ll_migrate(struct inode *parent, struct file *file, int mdtidx,
 	if (child_inode == NULL)
 		GOTO(out_free, rc = -EINVAL);
 
-	mutex_lock(&child_inode->i_mutex);
+	/*
+	 * lfs migrate command needs to be blocked on the client
+	 * by checking the migrate FID against the FID of the
+	 * filesystem root.
+	 */
+	if (child_inode == parent->i_sb->s_root->d_inode)
+		GOTO(out_iput, rc = -EINVAL);
+
+	inode_lock(child_inode);
 	op_data->op_fid3 = *ll_inode2fid(child_inode);
 	if (!fid_is_sane(&op_data->op_fid3)) {
 		CERROR("%s: migrate %s, but FID "DFID" is insane\n",
@@ -3099,7 +3107,8 @@ out_close:
 	if (rc == 0)
 		clear_nlink(child_inode);
 out_unlock:
-	mutex_unlock(&child_inode->i_mutex);
+	inode_unlock(child_inode);
+out_iput:
 	iput(child_inode);
 out_free:
 	ll_finish_md_op_data(op_data);
diff --git a/lustre/llite/llite_internal.h b/lustre/llite/llite_internal.h
index adbf9d3..94c8045 100644
--- a/lustre/llite/llite_internal.h
+++ b/lustre/llite/llite_internal.h
@@ -681,8 +681,6 @@ struct ll_file_data {
 	struct list_head fd_lccs; /* list of ll_cl_context */
 };
 
-extern spinlock_t inode_lock;
-
 extern struct proc_dir_entry *proc_lustre_fs_root;
 
 static inline struct inode *ll_info2i(struct ll_inode_info *lli)
diff --git a/lustre/llite/llite_lib.c b/lustre/llite/llite_lib.c
index d1050d4..bf80506 100644
--- a/lustre/llite/llite_lib.c
+++ b/lustre/llite/llite_lib.c
@@ -1521,10 +1521,10 @@ static int ll_md_setattr(struct dentry *dentry, struct md_op_data *op_data)
 	 * cache is not cleared yet. */
 	op_data->op_attr.ia_valid &= ~(TIMES_SET_FLAGS | ATTR_SIZE);
 	if (S_ISREG(inode->i_mode))
-		mutex_lock(&inode->i_mutex);
+		inode_lock(inode);
 	rc = simple_setattr(dentry, &op_data->op_attr);
 	if (S_ISREG(inode->i_mode))
-		mutex_unlock(&inode->i_mutex);
+		inode_unlock(inode);
 	op_data->op_attr.ia_valid = ia_valid;
 
 	rc = ll_update_inode(inode, &md);
@@ -1613,7 +1613,7 @@ int ll_setattr_raw(struct dentry *dentry, struct iattr *attr, bool hsm_import)
 	if (S_ISREG(inode->i_mode)) {
 		if (attr->ia_valid & ATTR_SIZE)
 			inode_dio_write_done(inode);
-		mutex_unlock(&inode->i_mutex);
+		inode_unlock(inode);
 	}
 
 	/* We always do an MDS RPC, even if we're only changing the size;
@@ -1690,7 +1690,7 @@ out:
 		ll_finish_md_op_data(op_data);
 
 	if (S_ISREG(inode->i_mode)) {
-		mutex_lock(&inode->i_mutex);
+		inode_lock(inode);
 		if ((attr->ia_valid & ATTR_SIZE) && !hsm_import)
 			inode_dio_wait(inode);
 	}
diff --git a/lustre/llite/llite_nfs.c b/lustre/llite/llite_nfs.c
index 9e19e78..bc238f5 100644
--- a/lustre/llite/llite_nfs.c
+++ b/lustre/llite/llite_nfs.c
@@ -247,13 +247,13 @@ static int ll_get_name(struct dentry *dentry, char *name,
 		GOTO(out, rc = PTR_ERR(op_data));
 
 	op_data->op_max_pages = ll_i2sbi(dir)->ll_md_brw_pages;
-	mutex_lock(&dir->i_mutex);
+	inode_lock(dir);
 #ifdef HAVE_DIR_CONTEXT
 	rc = ll_dir_read(dir, &pos, op_data, &lgd.ctx);
 #else
 	rc = ll_dir_read(dir, &pos, op_data, &lgd, ll_nfs_get_name_filldir);
 #endif
-	mutex_unlock(&dir->i_mutex);
+	inode_unlock(dir);
 	ll_finish_md_op_data(op_data);
 	if (!rc && !lgd.lgd_found)
 		rc = -ENOENT;
diff --git a/lustre/llite/lloop.c b/lustre/llite/lloop.c
index f3b9288..c20df96 100644
--- a/lustre/llite/lloop.c
+++ b/lustre/llite/lloop.c
@@ -277,9 +277,9 @@ static int do_bio_lustrebacked(struct lloop_device *lo, struct bio *head)
 	 *    be asked to write less pages once, this purely depends on
 	 *    implementation. Anyway, we should be careful to avoid deadlocking.
 	 */
-	mutex_lock(&inode->i_mutex);
+	inode_lock(inode);
 	bytes = ll_direct_rw_pages(env, io, rw, inode, pvec);
-	mutex_unlock(&inode->i_mutex);
+	inode_unlock(inode);
 	cl_io_fini(env, io);
 	return (bytes == pvec->ldp_size) ? 0 : (int)bytes;
 }
diff --git a/lustre/llite/rw26.c b/lustre/llite/rw26.c
index b362532..ad692db 100644
--- a/lustre/llite/rw26.c
+++ b/lustre/llite/rw26.c
@@ -388,7 +388,7 @@ ll_direct_IO(
 	 * 1. Need inode mutex to operate transient pages.
 	 */
 	if (iov_iter_rw(iter) == READ)
-		mutex_lock(&inode->i_mutex);
+		inode_lock(inode);
 
 	while (iov_iter_count(iter)) {
 		struct page **pages;
@@ -439,7 +439,7 @@ ll_direct_IO(
 	}
 out:
 	if (iov_iter_rw(iter) == READ)
-		mutex_unlock(&inode->i_mutex);
+		inode_unlock(inode);
 
 	if (tot_bytes > 0) {
 		struct vvp_io *vio = vvp_env_io(env);
diff --git a/lustre/llite/vvp_io.c b/lustre/llite/vvp_io.c
index cbc4997..8dc657b 100644
--- a/lustre/llite/vvp_io.c
+++ b/lustre/llite/vvp_io.c
@@ -736,7 +736,7 @@ static int vvp_io_setattr_start(const struct lu_env *env,
 	struct inode		*inode = vvp_object_inode(io->ci_obj);
 	struct ll_inode_info	*lli   = ll_i2info(inode);
 
-	mutex_lock(&inode->i_mutex);
+	inode_lock(inode);
 	if (cl_io_is_trunc(io)) {
 		down_write(&lli->lli_trunc_sem);
 		inode_dio_wait(inode);
@@ -762,7 +762,7 @@ static void vvp_io_setattr_end(const struct lu_env *env,
 		inode_dio_write_done(inode);
 		up_write(&lli->lli_trunc_sem);
 	}
-	mutex_unlock(&inode->i_mutex);
+	inode_unlock(inode);
 }
 
 static void vvp_io_setattr_fini(const struct lu_env *env,
diff --git a/lustre/llite/vvp_page.c b/lustre/llite/vvp_page.c
index 39f093b..e2afea4 100644
--- a/lustre/llite/vvp_page.c
+++ b/lustre/llite/vvp_page.c
@@ -468,9 +468,9 @@ static int vvp_transient_page_is_vmlocked(const struct lu_env *env,
 	struct inode    *inode = vvp_object_inode(slice->cpl_obj);
 	int	locked;
 
-	locked = !mutex_trylock(&inode->i_mutex);
+	locked = !inode_trylock(inode);
 	if (!locked)
-		mutex_unlock(&inode->i_mutex);
+		inode_unlock(inode);
 	return locked ? -EBUSY : -ENODATA;
 }
 
-- 
2.8.2

